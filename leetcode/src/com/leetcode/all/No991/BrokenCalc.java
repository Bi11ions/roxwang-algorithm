package com.leetcode.all.No991;

/**
 * 在显示着数字的坏计算器上，我们可以执行以下两种操作：
 * <p>
 * 双倍（Double）：将显示屏上的数字乘 2；
 * 递减（Decrement）：将显示屏上的数字减 1 。
 * 最初，计算器显示数字X。
 * <p>
 * 返回显示数字Y所需的最小操作数。
 * 示例 1：
 * <p>
 * 输入：X = 2, Y = 3
 * 输出：2
 * 解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
 * 示例 2：
 * <p>
 * 输入：X = 5, Y = 8
 * 输出：2
 * 解释：先递减，再双倍 {5 -> 4 -> 8}.
 * 示例 3：
 * <p>
 * 输入：X = 3, Y = 10
 * 输出：3
 * 解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
 * 示例 4：
 * <p>
 * 输入：X = 1024, Y = 1
 * 输出：1023
 * 解释：执行递减运算 1023 次
 * <p>
 * 提示：
 * 1 <= X <= 10^9
 * 1 <= Y <= 10^9
 */
public class BrokenCalc {

    /**
     * 使用贪心算法
     * <p>
     * 分析：
     * 当Y<X的值时，YY只能由XX不断的进行减11操作得到，共需要X-YX−Y次操作，因此这种情形下我们可以直接得到答案。
     * 当Y>X的值时，该问题必然有有解，因X可以不断的做乘2操作得到第一个大于等于Y的数Z，然后再执行Z−Y次减1操作最终得到Y。
     * 当Y>X时，假设我们已经得到了最短的操作序列为 [X, n_1, n_2, n_3......Y],其中 n_1, n_2, n_3 等为乘或减操作产生的中间值。
     * 我们可以按照Y是否为奇数来分情况讨论。
     * 当Y为奇数时，由于只有乘2和减1两种操作，又Y不可能由某个数乘2得到，所以这个最优的操作序列中倒数第二个中间值必定为Y+1, 我们记符号min(Y)为由X转换成Y的最小操作步骤数，则易得min(Y) = min(Y+1) + 1
     * 当Y为偶数时，不妨设Y=2*T,此时Y可以由T*2或2*T-1两种方式得到，若Y由T*2得到(即倒数第二个中间值为T),那么min(Y) = min(T）+ 1。
     * 若Y由2*T+1通过减1操作得到,则min(Y)=min(2*T+1)+1。由于2*T+1为奇数，由1可知该最优操作序列中倒数第三个数必为2*T+2=2*(T+1)2∗T+2=2∗(T+1)，
     * 故min(Y)=min(2*T+2)+2min(Y)=min(2∗T+2)+2。此时2*T+22∗T+2为一个偶数，他可以由(T+1)*2或2*(T+2)-1-1...得到。
     * 我们假设最优的解K使得 X→...→(T+K)→2∗(T+K)→2∗(T+K)−1→2∗(T+K)−2→...→Y 这样的操作序列最短。仔细观察可以发现，
     * 我们可以选择(T+K)这个节点通过K次-1操作得到TT然后进行一次乘2操作得到2T=Y，共需要K+1次。而若按照如上的操作序列我们需要2T+2K-2T+1=2K+1次操作。
     * 显然Y由-1操作得到的最少操作次数要大于Y由T*2得到的最少操作次数。因此当Y为偶数时，其前一个中间值必为Y/2。
     * <p>
     * 算法：
     * 根据上述分析，我们可以写出该贪心算法的递归写法
     * 当Y = X时，返回0
     * 当Y < X时，返回 X-Y
     * 当Y > X 且 Y为奇数时，我们可以得到当前最优序列中倒数第二个数为Y+1，递归求解到Y+1的最小操作次数。
     * 当Y > X 且 Y为偶数时, 我们可以得到当前最优序列中倒数第二个数为Y/2，递归求解到Y/2的最小操作次数。
     */
    public int brokenCalc(int X, int Y) {
        if (Y < X) {
            return X - Y;
        }

        if (X == Y) {
            return 0;
        }

        if (Y % 2 == 0) {
            return 1 + brokenCalc(X, Y / 2);
        } else {
            return 1 + brokenCalc(X, Y + 1);
        }
    }
}
